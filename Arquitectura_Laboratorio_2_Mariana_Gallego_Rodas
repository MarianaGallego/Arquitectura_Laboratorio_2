.data

	inputFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/input.txt"
	outputFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/criptogram.txt"
	mensajeAEncriptar: .space 1024
	MensajeDeError: .asciiz "No se leyó el archivo correctamente"

	ClaveMultiplicativa: .asciiz "Digite la clave multiplicativa que desea utilizar: "
	ClaveAditiva: .asciiz "\n Digite la clave aditiva que desea utilizar: "

.text
	main:
	
		#Ingresar mensaje
		jal leerMensaje
	
		#Ingresar claves
		jal leerClaves
	
		#Mostrar datos
		#jal mostrarDatos
		
		#Encriptar mensaje
		jal encriptarMensaje
		
		jal generarDocumento
	
	li $v0, 10
	syscall
	

	#------------------------------------ DECLARACIÓN DE FUNCIONES ------------------------------------#

	leerClaves:

		#---------------------- Clave multiplicativa ----------------------#

		#mostrar string
		li $v0, 4
		la $a0, ClaveMultiplicativa
		syscall
		
		#leer entero
		li $v0, 5
		syscall
		
		#Hacer espacio en memoria y guardar
		addi $sp, $sp, -4
		sw $v0, 0($sp)

		
		#------------------------- Clave aditiva -------------------------#

		#mostrar string
		li $v0, 4
		la $a0, ClaveAditiva
		syscall
		
		#leer entero
		li $v0, 5
		syscall
		
		#Hacer espacio en memoria y guardar
		addi $sp, $sp, -4
		sw $v0, 0($sp)
	jr $ra
	


	leerMensaje:

		#------------------------- Abrir archivo -------------------------#

		# Abrir el archivo
    		li $v0, 13
    		la $a0, inputFile
    		li $a1, 0
    		li $a2, 0
    		syscall
    		move $t0, $v0

    		
    		bltz $t0, errorHandler
    		
    		#------------------------- Leer archivo -------------------------#

    		li $v0, 14
    		move $a0, $t0
    		la $a1, mensajeAEncriptar
    		li $a2, 1024
    		syscall
    		
    		#------------------------- Llamar validador -------------------------#
    		move $t8, $ra #Guardar $ra de esta función porque al llamar la otra se cambia
    		
    		la $a3, mensajeAEncriptar
    		jal validarCantidadBytes
    		
    		move $ra, $t8 #Recuperar $ra

		# Guardar el string leído en la pila byte por byte usando `sb`
		la $t1, mensajeAEncriptar
		addi $sp, $sp, -1024
		li $t2, 0


		#----------------- Guardar cada byte en la pila -----------------#

		storeWhile:
			lb $t3, 0($t1)
			sb $t3, 0($sp)

			# Incrementar el contador y avanzar
			addi $t1, $t1, 1
			addi $sp, $sp, 1
			addi $t2, $t2, 1
		
			beqz $t3, endStoreWhile
		
			j storeWhile
		endStoreWhile:

		# Restaurar el puntero de la pila al inicio del string guardado
		sub $sp, $sp, $t2
		
	jr $ra
	
	
	validarCantidadBytes:
		li $t4, 0
    		move $t5, $a3
    		
    		contarLoop:
			lb $t6, 0($t5)
			beq $t6, 0, endContarLoop
		
			# Avanzar
			addi $t4, $t4, 1
			addi $t5, $t5, 1
			j contarLoop
		endContarLoop:
		
		#li $t7, -1
		#mul $t4, $t4, $t7
		
		li $v0, 1
		move $a0, $t4
		syscall
	jr $ra
	
	
	errorHandler:
	
		li $v0, 4
    		la $a0, MensajeDeError
    		syscall
    		
	jr $ra
	
	
	encriptarMensaje:
	
		addi $s0, $sp, 8
	
		lw $t0, 0($sp)#Aditiva
		lw $t1, 4($sp)#Multiplicativa
		
		add $t2, $zero, $zero # inicializar i = 0
		
		encryptWhile:
			add $t3, $t2, $s0
			
			lb $t4, 0($t3)
			beq $t4, $zero, endEncryptWhile
			
			# Convertir de ASCII a valor en el alfabeto (minúsculas)
    			li $t5, 97                   # ASCII de 'a'
    			sub $t6, $t4, $t5            # 'a' = 0, 'b' = 1, ..., 'z' = 25

    			# Aplicar el cifrado afín E(x) = (a * x + b) mod 26
    			mul $t6, $t6, $t1            # Multiplicar por a
    			add $t6, $t6, $t0            # Sumar b (usar $t4 como clave aditiva)
    			li $t7, 26                   # Tamaño del alfabeto (mod 26)
    			rem $t6, $t6, $t7            # Tomar el módulo 26

    			# Convertir de vuelta al valor ASCII (minúsculas)
    			add $t4, $t6, $t5            # Volver al rango ASCII (sumar 97)
			
			li $v0, 11
			move $a0, $t4
			syscall
			
			sb $a0, 0($t3) #En el mismo lugar donde estaba el byte, lo guarda pero cifrado
			
			addi $t2, $t2, 1
			j encryptWhile
		endEncryptWhile:
		
	jr $ra
	
	generarDocumento:
	
		# Abrir el archivo de salida en modo de escritura
    		li $v0, 13
    		la $a0, outputFile
    		li $a1, 1               # Modo de escritura
    		li $a2, 0               # Permisos (no necesarios)
    		syscall
    		move $t0, $v0           # Guardar el descriptor de archivo en $t0

    		bltz $t0, errorHandler  # Si hubo error al abrir el archivo, saltar a errorHandler

    		# Escribir el mensaje cifrado en el archivo
    		addi $t1, $sp, 8        # $t1 apunta al inicio del mensaje cifrado en la pila
    		writeLoop:
        		lb $a1, 0($t1)      # Leer un byte del mensaje cifrado
        		beqz $a1, endWrite  # Si es el fin del mensaje, salir del bucle

        		# Crear un buffer para escribir el byte
        		addi $sp, $sp, -4    # Reservar espacio en la pila
        		sb $a1, 0($sp)       # Almacenar el byte en la pila

        		# Escribir el byte en el archivo
        		li $v0, 15          # Syscall de escribir en archivo
        		move $a0, $t0       # Descriptor del archivo
        		la $a1, 0($sp)      # Dirección del buffer (byte a escribir)
        		li $a2, 1           # Escribir un byte
        		syscall

        		# Liberar el espacio de la pila
        		addi $sp, $sp, 4

        		# Avanzar al siguiente byte
        		addi $t1, $t1, 1
        		j writeLoop

    		endWrite:
        	# Cerrar el archivo de salida
        	li $v0, 16
        	move $a0, $t0           # Descriptor del archivo a cerrar
        	syscall
	jr $ra
	
	
	mostrarDatos:
	
		#Clave aditiva
		lb $a0, 0($sp)
    		li $v0, 1
    		syscall
    		
    		#Clave multiplicativa
    		lb $a0, 4($sp)
    		li $v0, 1
    		syscall
    		
    		addi $sp, $sp, 8
	
		#-------------- Mostrar cada byte que hay la pila --------------#

		mostrarLoop:
			lb $a0, 0($sp)
			beqz $a0, endMostrar
			li $v0, 11
			syscall
		
			# Avanzar
			addi $sp, $sp, 1
			j mostrarLoop
		endMostrar:
		
		
	jr $ra