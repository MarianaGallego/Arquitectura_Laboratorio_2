.data

	inputFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/input.txt"
	criptogramFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/criptogram.txt"
	decodedFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/decoded.txt"
	mensaje: .space 1024

	ClaveMultiplicativa: .asciiz "Digite la clave multiplicativa. Recuerde que debe ser un número COPRIMO con 26: "
	ClaveAditiva: .asciiz "\nDigite la clave aditiva. Recuerde que debe ser un número entre 0 y 25: "

	MensajeDeErrorDocumento: .asciiz "No se pudo leer el documento"
	MensajeDeErrorCantidadBytes: .asciiz "La cantidad de Bytes en el documento excede el valor máximo permitido"

.text
	main:
	
		# Definición del valor del módulo
		li $s2, 26
	
		# Llamada a leer mensaje de inputFile
		la $a3, inputFile
		jal leerMensaje
	
		# Llamada a ingresar claves
		jal leerClaves
		
		# Llamada a encriptar mensaje
		jal encriptarMensaje
		
		# Llamada a leer mensaje de outputFile
		la $a3, criptogramFile
		jal leerMensaje
		
		# Llamada a desencriptar mensaje
		jal desencriptarMensaje
	
	li $v0, 10
	syscall
	
	
	
	
	

	#---------------------------------------- DECLARACIÓN DE FUNCIONES ----------------------------------------#

	
	# Abre el archivo que contiene el mensaje a
	# encriptar o desencriptar utilizando el
	# Syscall 13, almacena la cadena de caracteres
	# en una posición temporal de memoria y
	# lo cierra utilizando el Syscall 16;
	# almacena los caracteres en la pila con ayuda
	# del Stack Pointer ($sp).
	# Los registros $t0 a $t3 almacenan el
	# resultado con el que se evalúa si se pudo 
	# abrir el archivo, la dirección temporal
	# de memoria donde se encuentra la cadena
	# de caracteres que se leyó, el valor que
	# controla el recorrido del mensaje, y los
	# bytes que se leen y se almacenan
	leerMensaje:

		#--------------------------- Abrir archivo --------------------------#
    		li $v0, 13
    		la $a0, ($a3)
    		li $a1, 0
    		li $a2, 0
    		syscall
    		move $t0, $v0

    		
    		bltz $t0, errorHandlerDocumento
    		
    		#--------------------------- Leer archivo ---------------------------#
    		li $v0, 14
    		move $a0, $t0
    		la $a1, mensaje
    		li $a2, 1024
    		syscall
    		
    		#-------------------------- Cerrar archivo --------------------------#
    		li $v0, 16
        	move $a0, $t0
        	syscall
    		
    		#------------------------- Llamar validador -------------------------#
    		addi $sp, $sp, -4
		sw $ra, 0($sp)
    		
    		la $a3, mensaje
    		jal validarCantidadBytes
    		
    		lw $ra, 0($sp)
		addi $sp, $sp, 4

		#------------------- Guardar cada byte en la pila -------------------#
		la $t1, mensaje
		li $t2, 0

		guardarWhile:
			lb $t3, 0($t1)
			sb $t3, 0($sp)

			addi $t1, $t1, 1
			addi $sp, $sp, 1
			addi $t2, $t2, 1
		
			beqz $t3, endGuardarWhile
		
			j guardarWhile
		endGuardarWhile:

		sub $sp, $sp, $t2
		
	jr $ra


	# Muestra mensaje al usuario,
	# lee los valores de cada clave
	# y los almacena en $s4 y $s5
	# respectivamente
	leerClaves:

		#--------------------- Clave multiplicativa ---------------------#
		li $v0, 4
		la $a0, ClaveMultiplicativa
		syscall
		
		li $v0, 5
		syscall
		move $s4, $v0
		
		#------------------------- Clave aditiva -------------------------#
		li $v0, 4
		la $a0, ClaveAditiva
		syscall
		
		li $v0, 5
		syscall
		move $s5, $v0
		
	jr $ra
	
	
	
	# Encripta el mensaje que se obtuvo
	# del documento inputFile aplicando
	# el método Afín y utilizando las
	# claves ingresadas por el usuario.
	# Los registros $t1 a $t8 almacenan
	# el valor ASCCI desde donde comienzan
	# las letras mayúsculas, el contador
	# que ayúdará a darle valor a $t3 que será la
	# dirección de pila en la que se está en la
	# iteración en curso, la posición en pila donde
	# está el byte que se va a encriptar, el
	# byte que se va a encriptar, el valor ASCCI
	# desde donde comienzan las letras minúsculas,
	# el resultado de las operaciones que se
	# deben hacer para aplicar el método Afin,
	# el valor del módulo que se va a usar y el
	# valor que usa el condicional para saber
	# si la letra que se va a encriptar es
	# mayúscula o minúscula.
	encriptarMensaje:
	
		move $t7, $s2
		li $t1, 65
		li $t5, 97
		add $t2, $zero, $zero
		
		encriptarWhile:
			add $t3, $sp, $t2
			
			lb $t4, 0($t3)
			beq $t4, $zero, endEncriptarWhile
			
    			sub $t6, $t4, $t5
    		
    			#------------ Validar mayúsculas y minúsculas ------------#		
    			slt $t8, $t6, $zero
    			bne $t8, $zero, elseCondicionalEncriptar	

    				mul $t6, $t6, $s4
    				add $t6, $t6, $s5
    				rem $t6, $t6, $t7

    				add $t4, $t6, $t5
    					
    			j endCondicionalEncriptar
    			elseCondicionalEncriptar:
    					
    				sub $t6, $t4, $t1
    					
    				mul $t6, $t6, $s4
    				add $t6, $t6, $s5
    				rem $t6, $t6, $t7

    				add $t4, $t6, $t1
    					
    			endCondicionalEncriptar:
			
			sb $t4, 0($t3)
			
			addi $t2, $t2, 1
			j encriptarWhile
		endEncriptarWhile:
		
		addi $sp, $sp, -4
		sw $ra, 0($sp)
		
		la $a3, criptogramFile
		jal generarDocumento
		
		lw $ra, 0($sp)
		addi $sp, $sp, 4
	
	jr $ra
	
	
	# Desencripta el mensaje que se obtuvo del
	# documento criptogram aplicando el método
	# Afín y utilizando las claves ingresadas
	# por el usuario. Para aplicar el método
	# Afin primero se debe calcular el inverso
	# multiplicativo modular de la clave
	# multiplicativa, para esto se llama la
	# función calcularInversoMultiplicativoModular.
	# Los registros $t2 a $t9 almacenan el contador
	# que ayúdará a darle valor a $t3 que será la
	# dirección de pila en la que se está en la
	# iteración en curso, la posición en pila donde 
	# está el byte que se va a desencriptar, el byte 
	# que se va a encriptar, el valor ASCCI desde donde
	# comienzan las letras minúsculas, el resultado
	# de las operaciones que se deben hacer para
	# aplicar el método Afin, el valor del módulo
	# que se va a usar, el valor que usa el condicional
	#  para saber si la letra que se va a encriptar
	# es, mayúscula o minúscula y el valor del inverso
	# multiplicativo que retorna la función
	# calcularInversoMultiplicativoModular.
	desencriptarMensaje:
	
		addi $sp, $sp, -4
		sw $ra, 0($sp)
		
		jal calcularInversoMultiplicativoModular
		
		lw $ra, 0($sp)
		addi $sp, $sp, 4
		
		move $t9, $t4 # $t4 tiene el inverso
		
		move $t7, $s2
		li $t5, 97
		add $t2, $zero, $zero
		
		desencriptarWhile:
		
			add $t3, $t2, $sp
			
			lb $t4, 0($t3)
			beq $t4, $zero, endDesencriptarWhile
			
    			
    			sub $t6, $t4, $t5
    		
    			#----------------- Validar mayúsculas y minúsculas -----------------#		
    			slt $t8, $t6, $zero
    			bne $t8, $zero, elseCondicionalDesencriptar

				sub $t6, $t6, $s5
				bgez $t6, condicionalDesencriptarMinuscula
    					add $t6, $t6, $t7
    				condicionalDesencriptarMinuscula:
    				mul $t6, $t6, $t9
    				div $t6, $t7
    				mfhi $t6

    				add $t4, $t6, $t5
    				
    				
    					
    			j endCondicionalDesencriptar
    			elseCondicionalDesencriptar:
    					
    				li $s3, 65
    				sub $t6, $t4, $s3
    					
    				sub $t6, $t6, $s5
    				bgez $t6, condicionalDesencriptarMayuscula
    					add $t6, $t6, $s2
    				condicionalDesencriptarMayuscula:
    				mul $t6, $t6, $t9
    				div $t6, $t7
    				mfhi $t6

    				addi $t4, $t6, 65
    				
    				
    					
    			endCondicionalDesencriptar:
			
			sb $t4, 0($t3)
			
			addi $t2, $t2, 1
			j desencriptarWhile
		endDesencriptarWhile:
		
		addi $sp, $sp, -4
		sw $ra, 0($sp)
		
		la $a3, decodedFile
		jal generarDocumento
		
		lw $ra, 0($sp)
		addi $sp, $sp, 4
	
	jr $ra
	
	
	
	# Verifica que el contenido del documento
	# de entrada no supere los 1024 bytes.
	# Los registros $t4 a $t9 (exceptuando $t8)
	# almacenan el contador que guarda la
	# cantidad de bytes que se leen,
	# la dirección temporal de memoria donde se
	# encuentra la cadena de caracteres que se
	# leyó, los bytes que se leen, el número
	# máximo de bytes permitidos en una cadena
	# y el valor que usa el condicional para saber
	# si el número de caracteres leidos excede
	# el número permitido o no. Si lo excede,
	# invoca a errorHandlerCantidadBytes.
	validarCantidadBytes:
	
		li $t4, 0
    		move $t5, $a3
    		
    		contarWhile:
			lb $t6, 0($t5)
			beq $t6, 0, endContarWhile
		
			addi $t4, $t4, 1
			addi $t5, $t5, 1
			j contarWhile
		endContarWhile:
		
		li $t7, 1025
		slt $t9, $t7, $t4
			bne $t9, $zero, else
				jr $ra	
			else:
				j errorHandlerCantidadBytes
				
	jr $ra
	
	
	# Se encarga de calcular en inverso
	# multiplicativo modular que se necesita
	# para desencriptar un byte usando el 
	# método Afin. El registro $t3 almacena
	# el valor del módulo que se va a utilizar,
	# $t4 a $t7 son los coeficientes
	# del algoritmo de Euclides, $t8 almacena el
	# valor del cociente de la división entre
	# la clave multiplicativa y el módulo y $t9
	# es un auxiliar para poder almacenar valores
	# de las operaciones que se realizan.
	# Esta función retorna el valor de $t4, que es
	# el inverso multiplicativo de la clave
	# multiplicativa.
	calcularInversoMultiplicativoModular:
	
    		move $t3, $s2
    		li $t9, 0
    		
    		li $t4, 1
    		li $t5, 0
    		li $t6, 0
    		li $t7, 1

		calcularWhile:

    			beq $s4, 1, endCalcularWhile

    			div $s4, $t3
    			mflo $t8

    			mul $t9, $t8, $t3
    			sub $s4, $s4, $t9

    			mul $t9, $t8, $t6
    			sub $t4, $t4, $t9
    			mul $t9, $t8, $t7
    			sub $t5, $t5, $t9

   			move $t9, $t3
    			move $t3, $s4
    			move $s4, $t9

    			move $t9, $t6
    			move $t6, $t4
    			move $t4, $t9

    			move $t9, $t7
    			move $t7, $t5
    			move $t5, $t9

    			j calcularWhile

		endCalcularWhile:
	
    		bgez $t4, fin
    		add $t4, $t4, $s2

		fin:
	
	jr $ra
	
	
	
	# Recorre la pila  y escribe cada
	# byte leído en el documento que
	# se le pasó como parémetro en $a3.
	# Utiliza el Syscall 13 para abrir
	# el archivo en que va a escribir.
	# Los registros $t0 y $t1 almacenan
	# el resultado que indica si el archivo
	# se pudo abrir y la posición en la que
	# se encuentra el Stack pointer ($sp).
	# El registro $a1 almacena el byte que
	# esta en la posición de pila que indica
	# %t1. También utiliza el Syscall 15 para
	# escribir en el documento que se le
	# indica a través del descriptor de
	# archivo y el Syscall 16 para cerrar
	# el documento.
	generarDocumento:
	
    		li $v0, 13
    		la $a0, ($a3)
    		li $a1, 1
    		li $a2, 0 
    		syscall
    		move $t0, $v0

    		bltz $t0, errorHandlerDocumento

    		addi $t1, $sp, 4
    		escribirWhile:
        		lb $a1, 0($t1)
        		beqz $a1, endEscribirWhile

        		addi $sp, $sp, -4
        		sb $a1, 0($sp)

        		li $v0, 15
        		move $a0, $t0
        		la $a1, 0($sp)
        		li $a2, 1
        		syscall

        		addi $sp, $sp, 4

        		addi $t1, $t1, 1
        		j escribirWhile

    		endEscribirWhile:
 
        	li $v0, 16
        	move $a0, $t0
        	syscall
	jr $ra
	



	#--------------------------------------------- ERROR HANDLERS ---------------------------------------------#
	
	# Muestra el mensaje de error y termina la ejecución del código
	# Se invoca cuando el documento
	# de entrada no se puede leer
	# correctamente
	errorHandlerDocumento:
	
		li $v0, 4
    		la $a0, MensajeDeErrorDocumento
    		syscall
    		
    		li $v0, 10
    		syscall
    		
	jr $ra
	
	
	# Muestra el mensaje de error y termina la ejecución del código.
	# Se invoca cuando el contenido 
	# del documento de entrada excede
	# el número de bytes permitidos
	errorHandlerCantidadBytes:
	
		li $v0, 4
    		la $a0, MensajeDeErrorCantidadBytes
    		syscall
    		
    		li $v0, 10
    		syscall
    		
	jr $ra