.data

	inputFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/input.txt"
	outputFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/criptogram.txt"
	mensajeAEncriptar: .space 1024

	ClaveMultiplicativa: .asciiz "Digite la clave multiplicativa. : "
	ClaveAditiva: .asciiz "\n Digite la clave aditiva que desea utilizar: "

	MensajeDeErrorDocumento: .asciiz "No se pudo leer el documento"
	MensajeDeErrorCantidadBytes: .asciiz "La cantidad de Bytes en el documento excede el valor máximo permitido"

.text
	main:
	
		#Ingresar mensaje
		jal leerMensaje
	
		#Ingresar claves
		jal leerClaves
		
		#Encriptar mensaje
		jal encriptarMensaje
		
		#Generar documento
		jal generarDocumento
	
	li $v0, 10
	syscall
	

	#------------------------------------ DECLARACIÓN DE FUNCIONES ------------------------------------#

	leerClaves:

		#---------------------- Clave multiplicativa ----------------------#

		#mostrar string
		li $v0, 4
		la $a0, ClaveMultiplicativa
		syscall
		
		#leer entero
		li $v0, 5
		syscall
		
		#Hacer espacio en memoria y guardar
		addi $sp, $sp, -4
		sb $v0, 0($sp)

		
		#------------------------- Clave aditiva -------------------------#

		#mostrar string
		li $v0, 4
		la $a0, ClaveAditiva
		syscall
		
		#leer entero
		li $v0, 5
		syscall
		
		#Hacer espacio en memoria y guardar
		addi $sp, $sp, -4
		sb $v0, 0($sp)
	jr $ra
	


	leerMensaje:

		#------------------------- Abrir archivo -------------------------#

		# Abrir el archivo
    		li $v0, 13
    		la $a0, inputFile
    		li $a1, 0
    		li $a2, 0
    		syscall
    		move $t0, $v0

    		
    		bltz $t0, errorHandlerDocumento
    		
    		#------------------------- Leer archivo -------------------------#

    		li $v0, 14
    		move $a0, $t0
    		la $a1, mensajeAEncriptar
    		li $a2, 1024
    		syscall
    		
    		#------------------------- Llamar validador -------------------------#
    		move $t8, $ra #Guardar $ra de esta función porque al llamar la otra se cambia
    		
    		la $a3, mensajeAEncriptar
    		jal validarCantidadBytes
    		
    		move $ra, $t8 #Recuperar $ra

		#----------------- Guardar cada byte en la pila -----------------#
		la $t1, mensajeAEncriptar
		add $sp, $sp, $t4
		li $t2, 0

		storeWhile:
			lb $t3, 0($t1)
			sb $t3, 0($sp)

			# Incrementar el contador y avanzar
			addi $t1, $t1, 1
			addi $sp, $sp, 1
			addi $t2, $t2, 1
		
			beqz $t3, endStoreWhile
		
			j storeWhile
		endStoreWhile:

		# Restaurar el puntero de la pila al inicio del string guardado
		sub $sp, $sp, $t2
		
	jr $ra
	
	
	validarCantidadBytes:
	
		li $t4, 0
    		move $t5, $a3
    		
    		contarLoop:
			lb $t6, 0($t5)
			beq $t6, 0, endContarLoop
		
			# Avanzar
			addi $t4, $t4, 1 #contador
			addi $t5, $t5, 1
			j contarLoop
		endContarLoop:
		
		li $t7, 1025
		slt $t9, $t7, $t4 # $t9 = 0 si $t4 <= $t7
			bne $t9, $zero, else
				jr $ra	
			else:
				j errorHandlerCantidadBytes
				
	jr $ra
	
	
	encriptarMensaje:
	
		addi $s0, $sp, 8
	
		lb $t0, 0($sp)#Aditiva
		lb $t1, 4($sp)#Multiplicativa
		
		add $t2, $zero, $zero # inicializar i = 0
		
		encryptWhile:
			add $t3, $t2, $s0
			
			lb $t4, 0($t3)
			beq $t4, $zero, endEncryptWhile
			
			# Convertir de ASCII a valor en el alfabeto (minúsculas)
    			li $t5, 97                   # ASCII de 'a'
    			sub $t6, $t4, $t5            # 'a' = 0, 'b' = 1, ..., 'z' = 25
    			
    			#----------------- Validar mayúsculas y minúsculas -----------------#
    			
    			slt $t8, $t6, $zero # $t8 = 1 $t6 < 0
    			bne $t8, $zero, elseCondicional	
    				# Aplicar el cifrado afín E(x) = (a * x + b) mod 26
    				mul $t6, $t6, $t1            # Multiplicar por a
    				add $t6, $t6, $t0            # Sumar b (usar $t4 como clave aditiva)
    				li $t7, 26                   # Tamaño del alfabeto (mod 26)
    				rem $t6, $t6, $t7            # Tomar el módulo 26

    				# Convertir de vuelta al valor ASCII (minúsculas)
    				add $t4, $t6, $t5            # Volver al rango ASCII (sumar 97)
    					
    			j endCondicional
    			elseCondicional:
    					
    				sub $t6, $t4, 65          # Convertir el carácter de ASCII a un valor entre 0 y 25 (A=0, B=1,...)
    					
    				mul $t6, $t6, $t1            # Multiplicar por a
    				add $t6, $t6, $t0            # Sumar b (usar $t4 como clave aditiva)
    				li $t7, 26                   # Tamaño del alfabeto (mod 26)
    				rem $t6, $t6, $t7            # Tomar el módulo 26

    				# Convertir de vuelta al valor ASCII (minúsculas)
    				addi $t4, $t6, 65            # Volver al rango ASCII (sumar 65)
    					
    			endCondicional:

			
			li $v0, 11
			move $a0, $t4
			syscall
			
			sb $a0, 0($t3) #En el mismo lugar donde estaba el byte, lo guarda pero cifrado
			
			addi $t2, $t2, 1
			j encryptWhile
		endEncryptWhile:
		
	jr $ra
	
	
	generarDocumento:
	
		# Abrir el archivo de salida en modo de escritura
    		li $v0, 13
    		la $a0, outputFile
    		li $a1, 1               # Modo de escritura
    		li $a2, 0               # Permisos (no necesarios)
    		syscall
    		move $t0, $v0           # Guardar el descriptor de archivo en $t0

    		bltz $t0, errorHandlerDocumento  # Si hubo error al abrir el archivo, saltar a errorHandlerDocumento

    		# Escribir el mensaje cifrado en el archivo
    		addi $t1, $sp, 8        # $t1 apunta al inicio del mensaje cifrado en la pila
    		writeLoop:
        		lb $a1, 0($t1)      # Leer un byte del mensaje cifrado
        		beqz $a1, endWrite  # Si es el fin del mensaje, salir del bucle

        		# Crear un buffer para escribir el byte
        		addi $sp, $sp, -4    # Reservar espacio en la pila
        		sb $a1, 0($sp)       # Almacenar el byte en la pila

        		# Escribir el byte en el archivo
        		li $v0, 15          # Syscall de escribir en archivo
        		move $a0, $t0       # Descriptor del archivo
        		la $a1, 0($sp)      # Dirección del buffer (byte a escribir)
        		li $a2, 1           # Escribir un byte
        		syscall

        		# Liberar el espacio de la pila
        		addi $sp, $sp, 4

        		# Avanzar al siguiente byte
        		addi $t1, $t1, 1
        		j writeLoop

    		endWrite:
        	# Cerrar el archivo de salida
        	li $v0, 16
        	move $a0, $t0           # Descriptor del archivo a cerrar
        	syscall
	jr $ra
	
	
	#------------------------------------ ERROR HANDLERS ------------------------------------#
	
	errorHandlerDocumento:
	
		li $v0, 4
    		la $a0, MensajeDeErrorDocumento
    		syscall
    		
    		li $v0, 10
    		syscall
    		
	jr $ra
	
	errorHandlerCantidadBytes:
	
		li $v0, 4
    		la $a0, MensajeDeErrorCantidadBytes
    		syscall
    		
    		li $v0, 10
    		syscall
    		
	jr $ra