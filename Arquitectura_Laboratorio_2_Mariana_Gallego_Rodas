.data

	inputFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/input.txt"
	criptogramFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/criptogram.txt"
	decodedFile: .asciiz "C:/Users/maria/OneDrive/Escritorio/Arquitectura_Laboratorio_2/decoded.txt"
	mensajeAEncriptar: .space 1024

	ClaveMultiplicativa: .asciiz "Digite la clave multiplicativa. Recuerde que debe ser un número COPRIMO con 26: "
	ClaveAditiva: .asciiz "\nDigite la clave aditiva. Recuerde que debe ser un número entre 0 y 25: "

	MensajeDeErrorDocumento: .asciiz "No se pudo leer el documento"
	MensajeDeErrorCantidadBytes: .asciiz "La cantidad de Bytes en el documento excede el valor máximo permitido"

.text
	main:
	
		# Definición del valor del módulo
		li $s2, 26
	
		# Llamada a ingresar mensaje
		la $a3, inputFile
		jal leerMensaje
	
		# Llamada a ingresar claves
		jal leerClaves
		
		# Llamada a encriptar mensaje
		jal encriptarMensaje
		
		# Llamada a desencriptar mensaje
		jal desencriptarMensaje
	
	li $v0, 10
	syscall
	
	
	
	
	

	#---------------------------------------- DECLARACIÓN DE FUNCIONES ----------------------------------------#

	
	# Abre el archivo que contiene el mensaje
	# a encriptar, y almacena los caracteres en
	# la pila con ayuda del Stack Pointer ($sp).
	# Los registros $t0 a $t3 almacenan el resultado
	# de si se pudo abrir el archivo, el valor de
	# $ra para cuando se va a llamar una función,
	# el mensaje que se leyó, los bytes que se leen
	# y los valores que controlan el recorrido del mensaje.
	leerMensaje:

		#--------------------------- Abrir archivo --------------------------#
    		li $v0, 13
    		la $a0, ($a3)
    		li $a1, 0
    		li $a2, 0
    		syscall
    		move $t0, $v0

    		
    		bltz $t0, errorHandlerDocumento
    		
    		#--------------------------- Leer archivo ---------------------------#
    		li $v0, 14
    		move $a0, $t0
    		la $a1, mensajeAEncriptar
    		li $a2, 1024
    		syscall
    		
    		#------------------------- Llamar validador -------------------------#
    		addi $sp, $sp, -4
		sw $ra, 0($sp)
    		
    		la $a3, mensajeAEncriptar
    		jal validarCantidadBytes
    		
    		lw $ra, 0($sp)
		addi $sp, $sp, 4

		#------------------- Guardar cada byte en la pila -------------------#
		la $t1, mensajeAEncriptar
		#add $sp, $sp, $t4
		li $t2, 0

		guardarWhile:
			lb $t3, 0($t1)
			sb $t3, 0($sp)

			addi $t1, $t1, 1
			addi $sp, $sp, 1
			addi $t2, $t2, 1
		
			beqz $t3, endGuardarWhile
		
			j guardarWhile
		endGuardarWhile:

		sub $sp, $sp, $t2
		
	jr $ra


	# Muestra mensaje al usuario,
	# lee los valores de cada clave
	# y los almacena en la pila con
	# ayuda del Stack Pointer ($sp)
	# y utilizando el Store Byte (sb)
	leerClaves:

		#--------------------- Clave multiplicativa ---------------------#
		li $v0, 4
		la $a0, ClaveMultiplicativa
		syscall
		
		li $v0, 5
		syscall
		
		addi $sp, $sp, -4
		sb $v0, 0($sp)

		#------------------------- Clave aditiva -------------------------#
		li $v0, 4
		la $a0, ClaveAditiva
		syscall
		
		li $v0, 5
		syscall
		
		addi $sp, $sp, -4
		sb $v0, 0($sp)
		
	jr $ra
	
	
	
	# Encripta el mensaje que se obtuvo
	# del documento de entrada aplicando
	# el método Afín y utilizando las
	# claves ingresadas por el usuario.
	# Los registros $t0 a $t8 almacenan
	# los bytes que se leen, la variable
	# que controla el ciclo que recorre
	# los caracteres del mensaje y
	# los resultados de las operaciones
	# que se realizan para aplicar el método Afin
	encriptarMensaje:
	
		addi $s0, $sp, 8
	
		lb $t0, 0($sp)
		lb $t1, 4($sp)
		
		add $t2, $zero, $zero
		
		encriptarWhile:
			add $t3, $t2, $s0
			
			lb $t4, 0($t3)
			beq $t4, $zero, endEncriptarWhile
			
    			li $t5, 97
    			sub $t6, $t4, $t5
    		
    			#------------ Validar mayúsculas y minúsculas ------------#		
    			slt $t8, $t6, $zero
    			bne $t8, $zero, elseCondicionalEncriptar	

    				mul $t6, $t6, $t1
    				add $t6, $t6, $t0
    				move $t7, $s2
    				rem $t6, $t6, $t7

    				add $t4, $t6, $t5
    					
    			j endCondicionalEncriptar
    			elseCondicionalEncriptar:
    					
    				sub $t6, $t4, 65
    					
    				mul $t6, $t6, $t1
    				add $t6, $t6, $t0
    				move $t7, $s2
    				rem $t6, $t6, $t7

    				addi $t4, $t6, 65
    					
    			endCondicionalEncriptar:
			
			li $v0, 11
			move $a0, $t4
			syscall
			
			sb $a0, 0($t3)
			
			addi $t2, $t2, 1
			j encriptarWhile
		endEncriptarWhile:
		
		addi $sp, $sp, -4
		sw $ra, 0($sp)
		
		la $a3, criptogramFile
		jal generarDocumento
		
		lw $ra, 0($sp)
		addi $sp, $sp, 4
	
	jr $ra
	
	
	
	desencriptarMensaje:
	
		addi $sp, $sp, -4
		sw $ra, 0($sp)
		
		lb $a1, 8($sp)
		jal calcularInversoMultiplicativoModular
		
		lw $ra, 0($sp)
		addi $sp, $sp, 4
		
		addi $s0, $sp, 8
		
		lb $t0, 0($sp)
		lb $t1, 4($sp)
		move $t9, $v1
		
		add $t2, $zero, $zero
		
		desencriptarWhile:
			add $t3, $t2, $s0
			
			lb $t4, 0($t3)
			beq $t4, $zero, endDesencriptarWhile
			
    			li $t5, 97
    			sub $t6, $t4, $t5
    		
    			#----------------- Validar mayúsculas y minúsculas -----------------#		
    			slt $t8, $t6, $zero
    			bne $t8, $zero, elseCondicionalDesencriptar

				sub $t6, $t6, $t0
				bgez $t6, condicionalDesencriptarMinuscula
    					add $t6, $t6, $s2
    				condicionalDesencriptarMinuscula:
    				mul $t6, $t6, $t9
    				move $t7, $s2
    				div $t6, $t7
    				mfhi $t6

    				add $t4, $t6, $t5
    				
    				
    					
    			j endCondicionalDesencriptar
    			elseCondicionalDesencriptar:
    					
    				li $s3, 65
    				sub $t6, $t4, $s3
    					
    				sub $t6, $t6, $t0
    				bgez $t6, condicionalDesencriptarMayuscula
    					add $t6, $t6, $s2
    				condicionalDesencriptarMayuscula:
    				mul $t6, $t6, $t9
    				move $t7, $s2
    				div $t6, $t7
    				mfhi $t6

    				addi $t4, $t6, 65
    				
    				
    					
    			endCondicionalDesencriptar:
			
			li $v0, 11
			move $a0, $t4
			syscall
			
			sb $a0, 0($t3)
			
			addi $t2, $t2, 1
			j desencriptarWhile
		endDesencriptarWhile:
		
		addi $sp, $sp, -4
		sw $ra, 0($sp)
		
		la $a3, decodedFile
		jal generarDocumento
		
		lw $ra, 0($sp)
		addi $sp, $sp, 4
	
	jr $ra
	
	
	
	# Verifica que el contenido del documento
	# de entrada no supere los 1024 bytes.
	# Los registros $t4 a $t9 almacenan
	# los bytes que se leen, la variable
	# que controla el ciclo que recorre
	# los caracteres del mensaje y los
	# valores que retornan las operaciones
	# condicionales
	validarCantidadBytes:
	
		li $t4, 0
    		move $t5, $a3
    		
    		contarWhile:
			lb $t6, 0($t5)
			beq $t6, 0, endContarWhile
		
			addi $t4, $t4, 1
			addi $t5, $t5, 1
			j contarWhile
		endContarWhile:
		
		li $t7, 1025
		slt $t9, $t7, $t4
			bne $t9, $zero, else
				jr $ra	
			else:
				j errorHandlerCantidadBytes
				
	jr $ra
	
	
	
	calcularInversoMultiplicativoModular:
	
		move $s0, $s2

    		move $t2, $a1
    		move $t3, $s0
    		li $t4, 1
    		li $t5, 0
    		li $t6, 0
    		li $t7, 1

		calcularWhile:

    			beq $t2, 1, endCalcularWhile

    			div $t2, $t3
    			mflo $t8

    			mul $t9, $t8, $t3
    			sub $t2, $t2, $t9

    			mul $t9, $t8, $t6
    			sub $t4, $t4, $t9
    			mul $t9, $t8, $t7
    			sub $t5, $t5, $t9

   			move $t9, $t3
    			move $t3, $t2
    			move $t2, $t9

    			move $t9, $t6
    			move $t6, $t4
    			move $t4, $t9

    			move $t9, $t7
    			move $t7, $t5
    			move $t5, $t9

    			j calcularWhile

		endCalcularWhile:
	
    		bgez $t4, mostrarInverso
    		add $t4, $t4, $s0
    		
    		move $v1, $t4

		mostrarInverso:
    			li $v0, 1
    			move $a0, $v1
    			syscall
    		
    			jr $ra
	
	jr $ra
	
	
	
	# Recorre la pila con el mensaje
	# encriptado y escribe cada byte
	# leído en el documento de salida.
	# Los registros $t0 a $t1 almacenan
	# El resultado de si se pudo abrir
	# el archivo y la posición de memoria
	# a partir de la que se encuentra el
	# mensaje encriptado.
	# El registro $a1 almacena los bytes
	# que se van cargando
	generarDocumento:
	
    		li $v0, 13
    		la $a0, ($a3)
    		li $a1, 1
    		li $a2, 0 
    		syscall
    		move $t0, $v0

    		bltz $t0, errorHandlerDocumento

    		addi $t1, $sp, 12
    		escribirWhile:
        		lb $a1, 0($t1)
        		beqz $a1, endEscribirWhile

        		addi $sp, $sp, -4
        		sb $a1, 0($sp)

        		li $v0, 15
        		move $a0, $t0
        		la $a1, 0($sp)
        		li $a2, 1
        		syscall

        		addi $sp, $sp, 4

        		addi $t1, $t1, 1
        		j escribirWhile

    		endEscribirWhile:
 
        	li $v0, 16
        	move $a0, $t0
        	syscall
	jr $ra
	



	#--------------------------------------------- ERROR HANDLERS ---------------------------------------------#
	
	# Muestra el mensaje de error y termina la ejecución del código
	# Se genera cuando el documento
	# de entrada no se puede leer
	# correctamente
	errorHandlerDocumento:
	
		li $v0, 4
    		la $a0, MensajeDeErrorDocumento
    		syscall
    		
    		li $v0, 10
    		syscall
    		
	jr $ra
	
	
	# Muestra el mensaje de error y termina la ejecución del código.
	# Se genera cuando el contenido 
	# del documento de entrada excede
	# el número de bytes permitidos
	errorHandlerCantidadBytes:
	
		li $v0, 4
    		la $a0, MensajeDeErrorCantidadBytes
    		syscall
    		
    		li $v0, 10
    		syscall
    		
	jr $ra